" rustlings_ko/mappings.vim - Korean translation mappings for Rust compiler messages
" Ported from rustlings-ko.nvim to classic Vim 8.2+
"
" Provides four lazy-loaded data sources and a lookup function:
"   rustlings_ko#mappings#lookup(message)         - main lookup entry point
"   rustlings_ko#mappings#get_error_codes()       - dict of E-codes -> Korean
"   rustlings_ko#mappings#get_patterns()           - list of regex pattern dicts
"   rustlings_ko#mappings#get_warnings()           - list of warning pattern dicts
"   rustlings_ko#mappings#get_hints()              - list of hint pattern dicts
"
" Maintainer: rustlings-ko contributors
" License: MIT

let s:save_cpo = &cpo
set cpo&vim

" ---------------------------------------------------------------------------
" Script-local cache variables (lazy init)
" ---------------------------------------------------------------------------
let s:error_codes = {}
let s:patterns = []
let s:warnings = []
let s:hints = []
let s:error_codes_loaded = 0
let s:patterns_loaded = 0
let s:warnings_loaded = 0
let s:hints_loaded = 0

" ---------------------------------------------------------------------------
" Main lookup function
" ---------------------------------------------------------------------------

" Attempt to translate {message} using error codes, patterns, warnings, hints.
" Returns the Korean translation string, or v:null if no match found.
function! rustlings_ko#mappings#lookup(message) abort
  if a:message ==# ''
    return v:null
  endif

  " 1. Try error code lookup (e.g. "error[E0308]: mismatched types")
  let l:code = s:extract_error_code(a:message)
  if l:code !=# ''
    let l:codes = rustlings_ko#mappings#get_error_codes()
    if has_key(l:codes, l:code)
      return l:codes[l:code]
    endif
  endif

  " 2. Try pattern matching
  let l:result = s:try_pattern_list(rustlings_ko#mappings#get_patterns(), a:message)
  if l:result isnot v:null
    return l:result
  endif

  " 3. Try warning patterns
  let l:result = s:try_pattern_list(rustlings_ko#mappings#get_warnings(), a:message)
  if l:result isnot v:null
    return l:result
  endif

  " 4. Try hint patterns
  let l:result = s:try_pattern_list(rustlings_ko#mappings#get_hints(), a:message)
  if l:result isnot v:null
    return l:result
  endif

  return v:null
endfunction

" ---------------------------------------------------------------------------
" Internal helpers
" ---------------------------------------------------------------------------

" Extract an error code like 'E0308' from a message.
function! s:extract_error_code(message) abort
  let l:m = matchlist(a:message, '\v\[?(E\d{4})\]?')
  if !empty(l:m)
    return l:m[1]
  endif
  return ''
endfunction

" Try matching a message against a list of pattern dicts.
" Each dict has 'pattern' (Vim regex) and 'translation' (Korean with %1/%2).
" Returns the translated string, or v:null if no match.
function! s:try_pattern_list(patterns, message) abort
  for l:entry in a:patterns
    let l:m = matchlist(a:message, l:entry.pattern)
    if !empty(l:m)
      let l:result = l:entry.translation
      if l:m[1] !=# ''
        let l:result = substitute(l:result, '%1', escape(l:m[1], '&~\'), 'g')
      endif
      if len(l:m) > 2 && l:m[2] !=# ''
        let l:result = substitute(l:result, '%2', escape(l:m[2], '&~\'), 'g')
      endif
      if len(l:m) > 3 && l:m[3] !=# ''
        let l:result = substitute(l:result, '%3', escape(l:m[3], '&~\'), 'g')
      endif
      return l:result
    endif
  endfor
  return v:null
endfunction

" ===========================================================================
" Error Codes (369 entries)
" ===========================================================================
function! rustlings_ko#mappings#get_error_codes() abort
  if s:error_codes_loaded
    return s:error_codes
  endif

  let s:error_codes = {
        \ 'E0001': '패턴에 도달할 수 없습니다',
        \ 'E0002': '패턴 매칭에서 빈 범위입니다',
        \ 'E0004': '패턴 매칭이 완전하지 않습니다',
        \ 'E0005': '반박 가능한 패턴입니다',
        \ 'E0007': '바인딩 패턴으로 이동할 수 없습니다',
        \ 'E0008': 'by-move 바인딩과 by-ref 바인딩을 동시에 사용할 수 없습니다',
        \ 'E0009': 'by-move 바인딩과 by-ref 바인딩을 동시에 사용할 수 없습니다',
        \ 'E0010': '상수에서 할당할 수 없습니다',
        \ 'E0013': '상수에서 정적 변수를 참조할 수 없습니다',
        \ 'E0014': '상수에서 소멸자를 사용할 수 없습니다',
        \ 'E0015': '상수가 아닌 함수 호출은 상수에서 사용할 수 없습니다',
        \ 'E0023': '패턴에서 필드 수가 일치하지 않습니다',
        \ 'E0025': '필드가 이미 바인딩되었습니다',
        \ 'E0026': '존재하지 않는 필드를 사용했습니다',
        \ 'E0027': '패턴에서 일부 필드가 누락되었습니다',
        \ 'E0029': '범위 패턴에 사용할 수 없는 타입입니다',
        \ 'E0030': '범위의 시작이 끝보다 큽니다',
        \ 'E0031': '값이 너무 큽니다',
        \ 'E0032': '필드가 아닌 것에 필드 패턴을 사용할 수 없습니다',
        \ 'E0033': '크기를 알 수 없는 타입입니다',
        \ 'E0034': '메서드가 모호합니다',
        \ 'E0038': '트레이트를 객체로 사용할 수 없습니다',
        \ 'E0040': '소멸자를 명시적으로 호출할 수 없습니다',
        \ 'E0044': '외부 함수에 타입 매개변수를 사용할 수 없습니다',
        \ 'E0046': '트레이트 구현에서 항목이 누락되었습니다',
        \ 'E0050': '구현된 메서드의 매개변수 수가 다릅니다',
        \ 'E0053': '구현된 메서드의 매개변수 타입이 다릅니다',
        \ 'E0054': '캐스팅할 수 없는 타입입니다',
        \ 'E0055': '강제 변환 횟수가 한도를 초과했습니다',
        \ 'E0057': '클로저에 전달된 인수의 수가 잘못되었습니다',
        \ 'E0060': '함수에 전달된 인수가 부족합니다',
        \ 'E0061': '함수에 전달된 인수의 수가 잘못되었습니다',
        \ 'E0063': '구조체 초기화에서 필드가 누락되었습니다',
        \ 'E0106': '수명 매개변수가 누락되었습니다',
        \ 'E0107': '제네릭 인수의 수가 잘못되었습니다',
        \ 'E0110': '수명 매개변수가 허용되지 않습니다',
        \ 'E0119': '충돌하는 트레이트 구현이 있습니다',
        \ 'E0120': 'Drop 트레이트를 명시적으로 구현할 수 없습니다',
        \ 'E0133': 'unsafe 블록이 필요합니다',
        \ 'E0152': 'lang 항목이 중복 정의되었습니다',
        \ 'E0154': '이름이 두 번 이상 가져와졌습니다',
        \ 'E0158': '참조 불가능한 패턴에서 상수를 사용할 수 없습니다',
        \ 'E0161': '크기를 알 수 없는 타입의 값을 이동할 수 없습니다',
        \ 'E0162': '반박 불가능한 if-let 패턴입니다',
        \ 'E0164': '함수가 아닌 항목에 함수 스타일 패턴을 사용할 수 없습니다',
        \ 'E0165': '반박 불가능한 while-let 패턴입니다',
        \ 'E0170': '패턴 바인딩이 열거형 배리언트를 가립니다',
        \ 'E0178': '연산자 우선순위에 의한 모호한 바운드입니다',
        \ 'E0184': 'Copy 트레이트 구현이 유효하지 않습니다',
        \ 'E0185': '트레이트에는 없는 &self 매개변수입니다',
        \ 'E0186': '트레이트에 있는 &self 매개변수가 없습니다',
        \ 'E0191': '관련 타입의 값이 지정되지 않았습니다',
        \ 'E0195': '트레이트 선언과 수명 매개변수가 다릅니다',
        \ 'E0199': '긍정적 트레이트 구현의 안전성이 맞지 않습니다',
        \ 'E0200': '부정적 트레이트 구현의 안전성이 맞지 않습니다',
        \ 'E0220': '관련 타입을 찾을 수 없습니다',
        \ 'E0221': '관련 타입이 모호합니다',
        \ 'E0223': '관련 타입을 모호하게 사용했습니다',
        \ 'E0225': '한 개의 non-auto 트레이트만 객체 타입에 사용할 수 있습니다',
        \ 'E0228': '관련 타입 바운드에 명시적 수명이 필요합니다',
        \ 'E0252': '이름이 이미 가져와져 있습니다',
        \ 'E0253': '외부에 정의되지 않은 값을 가져올 수 없습니다',
        \ 'E0254': '이미 정의된 extern crate와 충돌합니다',
        \ 'E0255': '이미 가져온 이름과 충돌합니다',
        \ 'E0259': 'extern crate 이름이 충돌합니다',
        \ 'E0260': '이름이 외부 크레이트와 충돌합니다',
        \ 'E0261': '선언되지 않은 수명을 사용했습니다',
        \ 'E0262': '잘못된 수명 매개변수 이름입니다',
        \ 'E0263': '수명 이름이 중복 선언되었습니다',
        \ 'E0267': '루프 밖에서 `break`를 사용할 수 없습니다',
        \ 'E0268': '루프 밖에서 `continue`를 사용할 수 없습니다',
        \ 'E0271': '관련 타입의 불일치',
        \ 'E0275': '트레이트 해결 중 오버플로가 발생했습니다',
        \ 'E0276': '트레이트 메서드의 where 절을 만족하지 않습니다',
        \ 'E0277': '트레이트 바운드가 충족되지 않았습니다',
        \ 'E0282': '타입 어노테이션이 필요합니다',
        \ 'E0283': '타입이 모호합니다',
        \ 'E0284': '관련 타입을 추론할 수 없습니다',
        \ 'E0301': 'match 가드에서 가변 참조를 사용할 수 없습니다',
        \ 'E0302': 'match 가드에서 값을 할당할 수 없습니다',
        \ 'E0303': 'match 가드에서 바인딩 모드가 일치하지 않습니다',
        \ 'E0308': '타입 불일치',
        \ 'E0309': '타입 매개변수의 수명 제약 조건 불충족',
        \ 'E0310': "'static 수명 제약 조건 불충족",
        \ 'E0312': '참조의 수명이 충분하지 않습니다',
        \ 'E0317': 'if/else 분기의 타입이 일치하지 않습니다',
        \ 'E0326': '관련 타입의 값이 예상 타입과 다릅니다',
        \ 'E0329': '관련 타입에 접근할 수 없습니다',
        \ 'E0336': '정적 수명이 아닙니다',
        \ 'E0364': '비공개 항목을 재내보내기할 수 없습니다',
        \ 'E0365': '비공개 모듈을 재내보내기할 수 없습니다',
        \ 'E0368': '해당 타입에 이 이항 연산자를 적용할 수 없습니다',
        \ 'E0369': '해당 타입에 이항 연산자를 적용할 수 없습니다',
        \ 'E0370': '열거형 판별자 값이 너무 큽니다',
        \ 'E0373': '클로저가 빌린 값보다 오래 살 수 있습니다',
        \ 'E0374': '빌려온 내용을 클로저 밖으로 이동할 수 없습니다',
        \ 'E0378': 'DispatchFromDyn 구현이 유효하지 않습니다',
        \ 'E0379': '트레이트의 const 함수는 허용되지 않습니다',
        \ 'E0380': 'auto 트레이트에 메서드나 관련 항목을 정의할 수 없습니다',
        \ 'E0382': '이동된 값을 사용했습니다',
        \ 'E0383': '부분적으로 이동된 값을 사용했습니다',
        \ 'E0384': '불변 변수에 재할당할 수 없습니다',
        \ 'E0390': '기본 타입에 대한 메서드 구현이 허용되지 않습니다',
        \ 'E0391': '순환 의존성이 감지되었습니다',
        \ 'E0392': '사용되지 않는 타입 매개변수입니다',
        \ 'E0393': '기본 타입 매개변수를 추론할 수 없습니다',
        \ 'E0398': '타입 매개변수가 너무 많습니다',
        \ 'E0399': '트레이트 구현에 불필요한 항목이 있습니다',
        \ 'E0401': '외부 함수의 타입 매개변수를 사용할 수 없습니다',
        \ 'E0403': '이름이 이미 타입 매개변수로 사용되고 있습니다',
        \ 'E0404': '타입이 아닌 것을 타입으로 사용했습니다',
        \ 'E0405': '트레이트가 아닌 것을 트레이트로 사용했습니다',
        \ 'E0407': '트레이트에 없는 메서드를 구현했습니다',
        \ 'E0408': '패턴의 모든 대안에 바인딩이 없습니다',
        \ 'E0409': '패턴 대안에서 바인딩 모드가 일치하지 않습니다',
        \ 'E0411': '`Self`를 이 컨텍스트에서 사용할 수 없습니다',
        \ 'E0412': '타입을 찾을 수 없습니다',
        \ 'E0415': '함수 매개변수 이름이 중복됩니다',
        \ 'E0416': '패턴에서 식별자가 두 번 이상 바인딩되었습니다',
        \ 'E0422': '모듈을 찾을 수 없습니다',
        \ 'E0423': '예상치 못한 항목 종류입니다',
        \ 'E0424': '`self`가 없는 곳에서 `self`를 사용했습니다',
        \ 'E0425': '이름을 찾을 수 없습니다',
        \ 'E0426': '매크로에서 사용할 수 없는 이름입니다',
        \ 'E0428': '이름이 이미 정의되어 있습니다',
        \ 'E0430': '`self`를 이 위치에서 가져올 수 없습니다',
        \ 'E0431': '잘못된 `self` 가져오기입니다',
        \ 'E0432': '가져오기를 해결할 수 없습니다',
        \ 'E0433': '크레이트나 모듈을 찾을 수 없습니다',
        \ 'E0434': '외부 함수의 변수를 사용할 수 없습니다',
        \ 'E0435': '상수가 아닌 값을 상수 컨텍스트에서 사용할 수 없습니다',
        \ 'E0436': '함수형 구조체의 가시성이 일치하지 않습니다',
        \ 'E0437': '트레이트에 없는 타입을 구현했습니다',
        \ 'E0438': '트레이트에 없는 상수를 구현했습니다',
        \ 'E0449': '불필요한 가시성 지정자입니다',
        \ 'E0451': '비공개 필드에 접근할 수 없습니다',
        \ 'E0453': '허용되지 않은 lint를 사용했습니다',
        \ 'E0458': '연결할 라이브러리 이름이 지정되지 않았습니다',
        \ 'E0463': '크레이트를 찾을 수 없습니다',
        \ 'E0466': '매크로 가져오기가 잘못되었습니다',
        \ 'E0468': '비 루트 모듈에서 매크로를 내보낼 수 없습니다',
        \ 'E0477': '수명 바운드가 충족되지 않았습니다',
        \ 'E0478': '수명 바운드가 충족되지 않았습니다',
        \ 'E0491': '참조의 수명이 충족되지 않았습니다',
        \ 'E0492': '상수에서 interior mutability를 사용할 수 없습니다',
        \ 'E0493': '상수에서 소멸자를 호출하는 값을 사용할 수 없습니다',
        \ 'E0495': '함수의 수명 요구사항을 추론할 수 없습니다',
        \ 'E0496': '수명 이름이 이미 사용 중입니다',
        \ 'E0497': '안정화되지 않은 기능을 사용했습니다',
        \ 'E0499': '가변 참조를 동시에 두 개 이상 만들 수 없습니다',
        \ 'E0502': '불변 참조가 있는 동안 가변 참조를 만들 수 없습니다',
        \ 'E0503': '빌린 값을 사용할 수 없습니다',
        \ 'E0505': '빌린 값을 이동할 수 없습니다',
        \ 'E0506': '빌린 값에 재할당할 수 없습니다',
        \ 'E0507': '공유 참조 뒤의 값을 이동할 수 없습니다',
        \ 'E0508': '인덱싱된 내용을 이동할 수 없습니다',
        \ 'E0509': 'Drop을 구현한 타입의 필드를 이동할 수 없습니다',
        \ 'E0515': '함수에서 로컬 변수의 참조를 반환할 수 없습니다',
        \ 'E0516': '`typeof`는 예약되었지만 구현되지 않았습니다',
        \ 'E0517': '잘못된 repr 속성입니다',
        \ 'E0518': '#[inline] 속성을 사용할 수 없는 위치입니다',
        \ 'E0520': '트레이트에 없는 항목에 대한 특수화입니다',
        \ 'E0521': '빌린 데이터가 클로저 밖으로 나갈 수 없습니다',
        \ 'E0525': '클로저가 `Fn` 트레이트를 구현하지 않습니다',
        \ 'E0527': '패턴에 슬라이스 요소 수가 일치하지 않습니다',
        \ 'E0528': '슬라이스 패턴에 요소가 부족합니다',
        \ 'E0529': '슬라이스가 아닌 타입에 슬라이스 패턴을 사용했습니다',
        \ 'E0530': '바인딩이 기존 이름을 가립니다',
        \ 'E0531': '알 수 없는 경로를 사용했습니다',
        \ 'E0532': '구조체나 열거형 배리언트가 예상되었습니다',
        \ 'E0533': '잘못된 항목 종류입니다',
        \ 'E0534': '속성에 인수가 너무 많습니다',
        \ 'E0535': '알 수 없는 인수입니다',
        \ 'E0536': '속성에 인수가 필요합니다',
        \ 'E0537': '알 수 없는 메타 항목입니다',
        \ 'E0559': '열거형 배리언트에 해당 필드가 없습니다',
        \ 'E0560': '구조체에 해당 필드가 없습니다',
        \ 'E0562': 'impl Trait를 이 위치에서 사용할 수 없습니다',
        \ 'E0574': '모듈이나 타입이 예상되었습니다',
        \ 'E0582': '수명이 관련 항목에서 사용되지 않았습니다',
        \ 'E0583': '파일을 찾을 수 없습니다',
        \ 'E0587': 'packed와 align repr을 동시에 사용할 수 없습니다',
        \ 'E0588': 'packed 구조체에서 정렬이 맞지 않는 필드를 사용할 수 없습니다',
        \ 'E0592': '동일한 이름의 메서드가 여러 개 존재합니다',
        \ 'E0593': '클로저/함수의 인수 수가 일치하지 않습니다',
        \ 'E0596': '불변 항목에 가변 참조를 만들 수 없습니다',
        \ 'E0597': '값이 충분히 오래 살지 못합니다',
        \ 'E0599': '해당 타입에 메서드를 찾을 수 없습니다',
        \ 'E0600': '단항 부정 연산자를 적용할 수 없습니다',
        \ 'E0601': '`main` 함수를 찾을 수 없습니다',
        \ 'E0603': '비공개 항목에 접근할 수 없습니다',
        \ 'E0604': '기본형으로만 캐스팅할 수 있습니다',
        \ 'E0605': '이 타입으로 캐스팅할 수 없습니다',
        \ 'E0606': '이 as 표현식으로 캐스팅할 수 없습니다',
        \ 'E0607': '얇은 포인터로 캐스팅할 수 없습니다',
        \ 'E0608': '인덱싱할 수 없는 타입입니다',
        \ 'E0609': '해당 필드가 없습니다',
        \ 'E0610': '역참조할 수 없는 타입입니다',
        \ 'E0614': '역참조할 수 없는 타입입니다',
        \ 'E0615': '메서드를 필드처럼 사용했습니다',
        \ 'E0616': '비공개 필드에 접근할 수 없습니다',
        \ 'E0617': '외부 함수에 잘못된 타입의 인수를 전달했습니다',
        \ 'E0618': '함수가 아닌 것을 호출하려 했습니다',
        \ 'E0620': '크기를 알 수 없는 타입을 캐스팅할 수 없습니다',
        \ 'E0621': '수명이 일치하지 않습니다',
        \ 'E0622': '내장 함수는 항목이 아닙니다',
        \ 'E0623': '수명이 일치하지 않습니다',
        \ 'E0624': '비공개 메서드에 접근할 수 없습니다',
        \ 'E0625': '너무 많은 열거형 배리언트에 매칭했습니다',
        \ 'E0626': '제너레이터/async 함수에서 빌린 값을 yield할 수 없습니다',
        \ 'E0627': 'yield 표현식이 잘못된 위치에 있습니다',
        \ 'E0628': '제너레이터에 인수를 전달할 수 없습니다',
        \ 'E0631': '클로저/함수의 인수 타입이 일치하지 않습니다',
        \ 'E0632': 'union 패턴에서 필드를 하나만 지정해야 합니다',
        \ 'E0633': '잘못된 `unwind` 속성입니다',
        \ 'E0634': '타입이 너무 큽니다',
        \ 'E0635': '알 수 없는 기능 이름입니다',
        \ 'E0636': '기능이 중복 정의되었습니다',
        \ 'E0637': "`'_`는 이 위치에서 사용할 수 없습니다",
        \ 'E0638': 'non-exhaustive 열거형에 대해 패턴이 완전하지 않습니다',
        \ 'E0639': '비공개 타입에 접근할 수 없습니다',
        \ 'E0642': '패턴에서 trait object를 사용할 수 없습니다',
        \ 'E0643': '수명 바운드 위치에서 impl Trait를 사용할 수 없습니다',
        \ 'E0646': '`main` 함수에 `#[start]`를 사용할 수 없습니다',
        \ 'E0647': '`start` 함수가 여러 번 정의되었습니다',
        \ 'E0648': '`export_name` 속성이 잘못되었습니다',
        \ 'E0658': '안정화되지 않은 기능을 사용했습니다',
        \ 'E0659': '이름이 모호합니다',
        \ 'E0689': '메서드 호출에서 타입이 모호합니다',
        \ 'E0692': 'transparent repr에 여러 필드가 있습니다',
        \ 'E0693': '잘못된 정렬 값입니다',
        \ 'E0695': '레이블 없는 블록에서 break할 수 없습니다',
        \ 'E0696': '블록에서 continue를 사용할 수 없습니다',
        \ 'E0728': '`await`는 `async` 함수나 블록에서만 사용할 수 있습니다',
        \ 'E0733': '재귀적 `async fn`은 허용되지 않습니다',
        \ 'E0734': '잘못된 `#[stable]` 속성입니다',
        \
        \ 'E0062': '구조체 리터럴에서 필드가 두 번 이상 지정되었습니다',
        \ 'E0064': '구조체 리터럴에 필드가 너무 많습니다',
        \ 'E0069': '`return`문에 값이 필요합니다',
        \ 'E0070': '잘못된 좌변 값에 할당을 시도했습니다',
        \ 'E0071': '구조체 초기화에 `{}` 문법을 사용해야 합니다',
        \ 'E0072': '재귀 타입은 크기를 알 수 없습니다 (`Box`를 사용하세요)',
        \ 'E0080': '상수 평가 중 오류가 발생했습니다',
        \ 'E0081': '열거형 판별자 값이 중복됩니다',
        \ 'E0084': '판별자가 없는 열거형에 repr 속성을 사용할 수 없습니다',
        \ 'E0091': '사용되지 않는 타입 매개변수입니다',
        \ 'E0092': '인식할 수 없는 내장 함수 이름입니다',
        \ 'E0093': '잘못된 내장 함수 선언입니다',
        \ 'E0094': '내장 함수의 타입 매개변수 수가 잘못되었습니다',
        \ 'E0108': '수명 매개변수가 너무 많습니다',
        \ 'E0116': '현재 크레이트에 정의되지 않은 타입에 inherent impl을 할 수 없습니다',
        \ 'E0117': '외부 타입에 외부 트레이트를 구현할 수 없습니다 (고아 규칙)',
        \ 'E0118': '기본 타입에 inherent impl을 할 수 없습니다',
        \ 'E0121': '타입 자리에 `_`를 사용할 수 없습니다',
        \ 'E0124': '구조체에 같은 이름의 필드가 두 개 이상 있습니다',
        \ 'E0128': '타입 매개변수의 기본값에 다른 타입 매개변수를 사용할 수 없습니다',
        \ 'E0130': '패턴에서 상수가 아닌 경로를 사용했습니다',
        \ 'E0131': '`main` 함수는 타입 매개변수를 가질 수 없습니다',
        \ 'E0132': '`#[start]` 함수가 잘못된 시그니처입니다',
        \ 'E0136': '`main` 함수가 아닌 곳에 진입점이 정의되었습니다',
        \ 'E0137': '동일한 함수에 두 개 이상의 `#[main]` 속성이 있습니다',
        \ 'E0138': '여러 개의 `#[start]` 함수가 정의되었습니다',
        \ 'E0201': '구현에서 중복된 정의가 있습니다',
        \ 'E0204': 'Copy를 구현할 수 없는 타입입니다',
        \ 'E0205': 'Copy를 구현할 수 없는 타입입니다',
        \ 'E0206': 'Copy를 구현할 수 없는 타입입니다',
        \ 'E0207': '구현에서 사용되지 않는 타입/수명 매개변수입니다',
        \ 'E0210': '트레이트 일관성 규칙을 위반했습니다',
        \ 'E0229': '관련 타입 바인딩이 잘못된 위치에 있습니다',
        \ 'E0243': '타입 인수가 너무 적습니다',
        \ 'E0244': '타입 인수가 너무 많습니다',
        \ 'E0246': '비정상적인 제네릭 인수 수입니다',
        \ 'E0248': '값이 아닌 곳에 값을 사용했습니다',
        \ 'E0297': '루프에서 반박 가능한 패턴을 사용했습니다',
        \ 'E0311': '수명 제약 조건을 추론할 수 없습니다',
        \ 'E0314': '제네릭 타입을 구체적으로 지정해야 합니다',
        \ 'E0315': '관련 타입 바운드에서 수명을 추론할 수 없습니다',
        \ 'E0316': '중첩된 `impl Trait`는 허용되지 않습니다',
        \ 'E0318': '`Sized` 트레이트를 역으로 구현할 수 없습니다',
        \ 'E0321': '교차 크레이트 트레이트 특수화가 허용되지 않습니다',
        \ 'E0322': '명시적 `Sized` 구현은 허용되지 않습니다',
        \ 'E0323': '연관 상수가 아닌 곳에 연관 상수를 정의했습니다',
        \ 'E0324': '연관 타입이 아닌 곳에 연관 타입을 정의했습니다',
        \ 'E0325': '연관 함수가 아닌 곳에 연관 함수를 정의했습니다',
        \ 'E0366': 'Drop을 구현할 수 없는 타입에 Drop을 구현했습니다',
        \ 'E0367': 'Drop 구현에 불필요한 타입 매개변수가 있습니다',
        \ 'E0371': '같은 trait를 두 번 구현할 수 없습니다',
        \ 'E0375': 'CoerceUnsized를 구현할 수 없는 타입입니다',
        \ 'E0376': 'CoerceUnsized 구현에서 단 하나의 필드만 변환해야 합니다',
        \ 'E0445': '비공개 트레이트를 공개 인터페이스에서 사용했습니다',
        \ 'E0446': '비공개 타입을 공개 인터페이스에서 사용했습니다',
        \ 'E0447': '가시성이 너무 제한적입니다',
        \ 'E0448': '가시성이 너무 넓습니다',
        \ 'E0452': '잘못된 lint 속성입니다',
        \ 'E0454': '`#[link]`에 `name` 값이 없습니다',
        \ 'E0455': '잘못된 링크 종류입니다',
        \ 'E0456': '알 수 없는 링크 종류입니다',
        \ 'E0457': '플러그인이 `#[plugin_registrar]` 함수를 제공하지 않습니다',
        \ 'E0459': '`#[link]`에 `name` 인수가 없습니다',
        \ 'E0460': '연결 매크로 호환성 불일치',
        \ 'E0461': '연결 라이브러리 형식 불일치',
        \ 'E0462': '연결 라이브러리를 찾을 수 없습니다',
        \ 'E0464': '여러 버전의 크레이트가 연결되었습니다',
        \ 'E0465': '같은 크레이트의 여러 버전이 사용되었습니다',
        \ 'E0469': '가져온 매크로를 찾을 수 없습니다',
        \ 'E0519': '현재 크레이트 타입에서 이 엔트리 포인트를 사용할 수 없습니다',
        \ 'E0522': '`#[lang]` 속성이 잘못 사용되었습니다',
        \ 'E0524': '빌려진 값을 캡처하는 클로저에 `move`를 사용할 수 없습니다',
        \ 'E0554': '#![feature] 속성은 nightly에서만 사용할 수 있습니다',
        \ 'E0561': '함수 포인터 반환형에 `impl Trait`를 사용할 수 없습니다',
        \ 'E0563': '수명이 관련 타입에서 사용되지 않았습니다',
        \ 'E0564': '타입 어노테이션에 수명이 필요합니다',
        \ 'E0565': '잘못된 리터럴 값의 메타 항목입니다',
        \ 'E0567': 'auto 트레이트에 제네릭 매개변수를 사용할 수 없습니다',
        \ 'E0568': 'auto 트레이트에 super 트레이트를 추가할 수 없습니다',
        \ 'E0569': 'auto 트레이트에 메서드가 있을 수 없습니다',
        \ 'E0570': '대상 기능 사양에 잘못된 값이 있습니다',
        \ 'E0571': '`break`에 값을 사용할 수 없는 위치입니다',
        \ 'E0572': '`return`문에 값을 잘못 사용했습니다',
        \ 'E0573': '예상된 종류와 다른 종류가 발견되었습니다',
        \ 'E0575': '항목이 예상되었지만 다른 것이 발견되었습니다',
        \ 'E0576': '관련 항목을 찾을 수 없습니다',
        \ 'E0577': '모듈이 예상되었지만 다른 것이 발견되었습니다',
        \ 'E0578': '모듈 경로의 상위 항목이 모듈이 아닙니다',
        \ 'E0579': 'fn 아이템이 매칭되지 않습니다',
        \ 'E0580': '`main` 함수의 시그니처가 올바르지 않습니다',
        \ 'E0581': '반환 타입의 수명이 지정되지 않았습니다',
        \ 'E0582': '수명이 함수 시그니처에서 사용되지 않았습니다',
        \ 'E0584': '포함 모듈이 공개가 아닙니다',
        \ 'E0585': '문서 주석이 잘못된 위치에 있습니다',
        \ 'E0586': '포괄 범위 패턴 `..` 뒤에 추가 요소가 있습니다',
        \ 'E0589': '`repr(packed)`와 `repr(align)`를 동시에 사용할 수 없습니다',
        \ 'E0590': '`break`나 `continue`에 유효하지 않은 레이블입니다',
        \ 'E0591': '함수 포인터 사용이 잘못되었습니다',
        \ 'E0594': '불변 항목에 할당할 수 없습니다',
        \ 'E0595': '클로저에서 불변 바인딩을 캡처할 수 없습니다',
        \ 'E0598': '빌린 값에 할당할 수 없습니다',
        \ 'E0602': '알 수 없는 lint 이름입니다',
        \ 'E0611': '비공개 구조체 필드에 패턴 매칭할 수 없습니다',
        \ 'E0612': '익명 필드에 숫자 인덱스로 접근해야 합니다',
        \ 'E0613': '존재하지 않는 튜플 인덱스입니다',
        \ 'E0619': '강제 변환 규칙에 의해 타입이 일치하지 않습니다',
        \ 'E0629': '`...` 패턴은 제거되었습니다 (`..=`를 사용하세요)',
        \ 'E0630': '잘못된 바이너리 연산자 오버로드입니다',
        \ 'E0640': '알 수 없는 extern ABI입니다',
        \ 'E0641': '유니온 필드에 `#[non_exhaustive]`를 사용할 수 없습니다',
        \ 'E0644': '클로저/제너레이터 타입은 전역에서 사용할 수 없습니다',
        \ 'E0645': '수명/타입 바운드에서 `impl Trait`를 사용할 수 없습니다',
        \ 'E0658': '안정화되지 않은 기능을 사용했습니다',
        \ 'E0698': '`async fn`에서 타입 어노테이션이 필요합니다',
        \ 'E0700': '리턴에서 `impl Trait`가 수명을 캡처하지 못합니다',
        \ 'E0706': '트레이트에서 `async fn`은 지원되지 않습니다',
        \ 'E0716': '임시 값이 충분히 오래 살지 못합니다',
        \ 'E0720': '불투명 타입이 자기 자신을 참조합니다',
        \ 'E0746': '반환 타입에 `impl Trait`가 필요합니다',
        \ 'E0747': '제네릭 인수의 순서가 잘못되었습니다',
        \ 'E0758': '`#[doc(alias)]` 속성값이 올바르지 않습니다',
        \ 'E0759': '`impl Trait` 반환 타입의 수명이 충분하지 않습니다',
        \ 'E0764': '가변 참조를 상수 컨텍스트에서 사용할 수 없습니다',
        \ 'E0767': '기본 타입에 대한 패턴 매칭이 허용되지 않습니다',
        \ 'E0774': '#[derive]는 struct, enum, union에만 사용할 수 있습니다',
        \ 'E0782': '트레이트 객체에는 `dyn` 키워드가 필요합니다',
        \ 'E0785': '예상치 못한 `impl Trait` 타입입니다',
        \ 'E0786': '잘못된 `const` 매개변수 타입입니다',
        \ 'E0790': '정규화된 경로를 사용해야 합니다',
        \ 'E0791': '정적 참조가 불일치합니다',
        \ 'E0792': '불투명 타입의 기대 조건이 충족되지 않습니다',
        \ 'E0793': '유니온 필드에 `ManuallyDrop`이 아닌 `Drop` 타입을 사용할 수 없습니다',
        \ }

  let s:error_codes_loaded = 1
  return s:error_codes
endfunction

" ===========================================================================
" Patterns (120 entries)
"
" Each entry: {'pattern': <vim regex>, 'translation': <Korean with %1/%2>}
" ===========================================================================
function! rustlings_ko#mappings#get_patterns() abort
  if s:patterns_loaded
    return s:patterns
  endif

  let s:patterns = [
        \ {'pattern': 'expected `\([^`]*\)`, found `\([^`]*\)`',
        \  'translation': '`%1` 타입이 예상되었지만 `%2` 타입이 발견되었습니다'},
        \ {'pattern': 'expected \(.\+\) found \(.\+\)',
        \  'translation': '%1 예상되었지만 %2 발견되었습니다'},
        \ {'pattern': 'mismatched types',
        \  'translation': '타입이 일치하지 않습니다'},
        \ {'pattern': 'the trait bound `\([^`]*\)`\s\+is not satisfied',
        \  'translation': '트레이트 바운드 `%1`이(가) 충족되지 않았습니다'},
        \ {'pattern': 'the trait `\([^`]*\)`\s\+is not implemented for `\([^`]*\)`',
        \  'translation': '`%2` 타입에 대해 트레이트 `%1`이(가) 구현되지 않았습니다'},
        \ {'pattern': "doesn't implement `\\([^`]*\\)`",
        \  'translation': '`%1`을(를) 구현하지 않습니다'},
        \ {'pattern': 'cannot borrow `\([^`]*\)`\s\+as mutable, as it is not declared as mutable',
        \  'translation': '`%1`을(를) 가변으로 빌릴 수 없습니다 (mut로 선언되지 않았습니다)'},
        \ {'pattern': 'cannot borrow `\([^`]*\)`\s\+as mutable more than once at a time',
        \  'translation': '`%1`에 대한 가변 참조를 동시에 두 개 이상 만들 수 없습니다'},
        \ {'pattern': 'cannot borrow `\([^`]*\)`\s\+as immutable because it is also borrowed as mutable',
        \  'translation': '`%1`이(가) 가변으로 빌려진 동안 불변으로 빌릴 수 없습니다'},
        \ {'pattern': 'cannot move out of `\([^`]*\)`',
        \  'translation': '`%1`에서 값을 이동할 수 없습니다'},
        \ {'pattern': 'cannot move out of borrowed content',
        \  'translation': '빌린 내용에서 값을 이동할 수 없습니다'},
        \ {'pattern': 'use of moved value: `\([^`]*\)`',
        \  'translation': '이동된 값을 사용했습니다: `%1`'},
        \ {'pattern': 'value used here after move',
        \  'translation': '이동 후 여기에서 값이 사용되었습니다'},
        \ {'pattern': 'borrow of moved value: `\([^`]*\)`',
        \  'translation': '이동된 값을 빌렸습니다: `%1`'},
        \ {'pattern': '`\([^`]*\)`\s\+does not live long enough',
        \  'translation': '`%1`의 수명이 충분하지 않습니다'},
        \ {'pattern': 'lifetime `\([^`]*\)`\s\+does not live long enough',
        \  'translation': '수명 `%1`이(가) 충분히 길지 않습니다'},
        \ {'pattern': 'missing lifetime specifier',
        \  'translation': '수명 지정자가 누락되었습니다'},
        \ {'pattern': 'cannot find value `\([^`]*\)`\s\+in this scope',
        \  'translation': '이 스코프에서 값 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'cannot find type `\([^`]*\)`\s\+in this scope',
        \  'translation': '이 스코프에서 타입 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'cannot find trait `\([^`]*\)`\s\+in this scope',
        \  'translation': '이 스코프에서 트레이트 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'cannot find macro `\([^`]*\)`\s\+in this scope',
        \  'translation': '이 스코프에서 매크로 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'not found in this scope',
        \  'translation': '이 스코프에서 찾을 수 없습니다'},
        \ {'pattern': 'this function takes \(\d\+\) arguments\= but \(\d\+\) arguments\= were supplied',
        \  'translation': '이 함수는 %1개의 인수를 받지만 %2개의 인수가 전달되었습니다'},
        \ {'pattern': 'this function takes \(\d\+\) arguments\= but \(\d\+\) arguments\= was supplied',
        \  'translation': '이 함수는 %1개의 인수를 받지만 %2개의 인수가 전달되었습니다'},
        \ {'pattern': 'no method named `\([^`]*\)`\s\+found for \(.\+\) in the current scope',
        \  'translation': '현재 스코프에서 %2에 대한 메서드 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'no field `\([^`]*\)`\s\+on type `\([^`]*\)`',
        \  'translation': '타입 `%2`에 필드 `%1`이(가) 없습니다'},
        \ {'pattern': 'unused variable: `\([^`]*\)`',
        \  'translation': '사용되지 않는 변수: `%1`'},
        \ {'pattern': 'unused import: `\([^`]*\)`',
        \  'translation': '사용되지 않는 가져오기: `%1`'},
        \ {'pattern': 'unused mut',
        \  'translation': '불필요한 mut 지정자'},
        \ {'pattern': 'variable does not need to be mutable',
        \  'translation': '변수를 가변으로 지정할 필요가 없습니다'},
        \ {'pattern': 'cannot assign to `\([^`]*\)`, as it is not declared as mutable',
        \  'translation': '`%1`에 할당할 수 없습니다 (mut로 선언되지 않았습니다)'},
        \ {'pattern': 'cannot assign twice to immutable variable `\([^`]*\)`',
        \  'translation': '불변 변수 `%1`에 두 번 할당할 수 없습니다'},
        \ {'pattern': 'cannot assign to immutable',
        \  'translation': '불변 항목에 할당할 수 없습니다'},
        \ {'pattern': 'call to unsafe function is unsafe and requires unsafe',
        \  'translation': '안전하지 않은 함수 호출이며 unsafe 블록이 필요합니다'},
        \ {'pattern': 'this operation is unsafe and requires an unsafe',
        \  'translation': '이 연산은 안전하지 않으며 unsafe 블록이 필요합니다'},
        \ {'pattern': 'unresolved import `\([^`]*\)`',
        \  'translation': '해결되지 않은 가져오기: `%1`'},
        \ {'pattern': 'could not find `\([^`]*\)`\s\+in `\([^`]*\)`',
        \  'translation': '`%2`에서 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'failed to resolve: use of undeclared',
        \  'translation': '선언되지 않은 항목을 사용하여 해결할 수 없습니다'},
        \ {'pattern': 'non-exhaustive patterns: `\([^`]*\)`\s\+not covered',
        \  'translation': '완전하지 않은 패턴: `%1`이(가) 처리되지 않았습니다'},
        \ {'pattern': 'non-exhaustive patterns',
        \  'translation': '완전하지 않은 패턴입니다'},
        \ {'pattern': 'type `\([^`]*\)`\s\+cannot be dereferenced',
        \  'translation': '타입 `%1`을(를) 역참조할 수 없습니다'},
        \ {'pattern': 'the size for values of type `\([^`]*\)`\s\+cannot be known at compilation time',
        \  'translation': '컴파일 시점에 타입 `%1`의 크기를 알 수 없습니다'},
        \ {'pattern': "doesn't have a size known at compile-time",
        \  'translation': '컴파일 시점에 크기를 알 수 없습니다'},
        \ {'pattern': 'match arms have incompatible types',
        \  'translation': 'match 갈래의 타입이 호환되지 않습니다'},
        \ {'pattern': 'if and else have incompatible types',
        \  'translation': 'if와 else의 타입이 호환되지 않습니다'},
        \ {'pattern': 'implicitly returns `()`\s\+as its body has no tail or `return` expression',
        \  'translation': '함수 본문에 꼬리 표현식이나 `return`이 없어 암묵적으로 `()`를 반환합니다'},
        \
        \ {'pattern': '`break`\s\+outside of a loop',
        \  'translation': '`break`는 루프 밖에서 사용할 수 없습니다'},
        \ {'pattern': '`continue`\s\+outside of a loop',
        \  'translation': '`continue`는 루프 밖에서 사용할 수 없습니다'},
        \ {'pattern': '`return`\s\+outside of a function',
        \  'translation': '`return`은 함수 밖에서 사용할 수 없습니다'},
        \
        \ {'pattern': 'expected one of .\+ found `\([^`]*\)`',
        \  'translation': '`%1`이(가) 아닌 다른 토큰이 예상되었습니다'},
        \ {'pattern': 'expected `;`, found `\([^`]*\)`',
        \  'translation': '`;`가 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected `,`, found `\([^`]*\)`',
        \  'translation': '`,`가 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected `{`, found `\([^`]*\)`',
        \  'translation': '`{`가 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected `}`, found `\([^`]*\)`',
        \  'translation': '`}`가 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected expression, found `\([^`]*\)`',
        \  'translation': '표현식이 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected expression, found keyword `\([^`]*\)`',
        \  'translation': '표현식이 예상되었지만 키워드 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected item, found `\([^`]*\)`',
        \  'translation': '항목이 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected type, found `\([^`]*\)`',
        \  'translation': '타입이 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected identifier, found keyword `\([^`]*\)`',
        \  'translation': '식별자가 예상되었지만 키워드 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'expected identifier, found `\([^`]*\)`',
        \  'translation': '식별자가 예상되었지만 `%1`이(가) 발견되었습니다'},
        \ {'pattern': 'unexpected token: `\([^`]*\)`',
        \  'translation': '예상치 못한 토큰: `%1`'},
        \
        \ {'pattern': 'cannot find module `\([^`]*\)`',
        \  'translation': '모듈 `%1`을(를) 찾을 수 없습니다'},
        \ {'pattern': 'file not found for module `\([^`]*\)`',
        \  'translation': '모듈 `%1`에 해당하는 파일을 찾을 수 없습니다'},
        \ {'pattern': 'cannot find crate for `\([^`]*\)`',
        \  'translation': '크레이트 `%1`을(를) 찾을 수 없습니다'},
        \
        \ {'pattern': 'missing fields\= `\([^`]*\)`\s\+in initializer of `\([^`]*\)`',
        \  'translation': '`%2` 초기화에서 필드 `%1`이(가) 누락되었습니다'},
        \ {'pattern': 'missing fields\= in initializer',
        \  'translation': '초기화에서 필드가 누락되었습니다'},
        \ {'pattern': 'missing match arm.*`\([^`]*\)`\s\+not covered',
        \  'translation': 'match에서 `%1` 패턴이 처리되지 않았습니다'},
        \ {'pattern': 'missing `fn main`',
        \  'translation': '`fn main` 함수가 없습니다'},
        \
        \ {'pattern': 'cannot return reference to local variable `\([^`]*\)`',
        \  'translation': '지역 변수 `%1`의 참조를 반환할 수 없습니다'},
        \ {'pattern': 'cannot return reference to temporary value',
        \  'translation': '임시 값의 참조를 반환할 수 없습니다'},
        \ {'pattern': 'returns a reference to data owned by the current function',
        \  'translation': '현재 함수가 소유한 데이터의 참조를 반환합니다'},
        \ {'pattern': 'borrowed data escapes outside of',
        \  'translation': '빌린 데이터가 스코프 바깥으로 벗어납니다'},
        \ {'pattern': 'closure may outlive the current function',
        \  'translation': '클로저가 현재 함수보다 오래 살 수 있습니다'},
        \
        \ {'pattern': 'conflicting implementations of trait `\([^`]*\)` for type `\([^`]*\)`',
        \  'translation': '타입 `%2`에 대해 트레이트 `%1`의 구현이 충돌합니다'},
        \ {'pattern': 'conflicting implementations',
        \  'translation': '구현이 충돌합니다'},
        \ {'pattern': 'duplicate definitions with name `\([^`]*\)`',
        \  'translation': '`%1`이(가) 중복 정의되었습니다'},
        \ {'pattern': 'multiple applicable items in scope',
        \  'translation': '스코프에 적용 가능한 항목이 여러 개 있습니다'},
        \
        \ {'pattern': 'cannot borrow `\([^`]*\)`\s\+as mutable because it is also borrowed as immutable',
        \  'translation': '`%1`이(가) 불변으로 빌려진 동안 가변으로 빌릴 수 없습니다'},
        \ {'pattern': 'cannot borrow `\([^`]*\)`\s\+as mutable',
        \  'translation': '`%1`을(를) 가변으로 빌릴 수 없습니다'},
        \
        \ {'pattern': 'private type `\([^`]*\)`\s\+in public interface',
        \  'translation': '공개 인터페이스에 비공개 타입 `%1`이(가) 사용되었습니다'},
        \ {'pattern': 'private field `\([^`]*\)`',
        \  'translation': '비공개 필드 `%1`'},
        \
        \ {'pattern': 'this struct takes \(\d\+\) fields\= but \(\d\+\) fields\= were supplied',
        \  'translation': '이 구조체는 %1개의 필드를 가지지만 %2개의 필드가 전달되었습니다'},
        \ {'pattern': 'this enum variant takes \(\d\+\) arguments\= but \(\d\+\) arguments\= were supplied',
        \  'translation': '이 열거형 변형은 %1개의 인수를 받지만 %2개가 전달되었습니다'},
        \ {'pattern': 'missing generics for \(\w\+\) `\([^`]*\)`',
        \  'translation': '%1 `%2`에 제네릭 매개변수가 누락되었습니다'},
        \
        \ {'pattern': '`await`\s\+is only allowed inside `async`',
        \  'translation': '`await`는 `async` 함수나 블록 안에서만 사용할 수 있습니다'},
        \ {'pattern': '`\([^`]*\)` is not a future',
        \  'translation': '`%1`은(는) Future가 아닙니다'},
        \
        \ {'pattern': 'recursive type `\([^`]*\)` has infinite size',
        \  'translation': '재귀 타입 `%1`은(는) 크기가 무한합니다 (Box를 사용하세요)'},
        \ {'pattern': 'recursive type has infinite size',
        \  'translation': '재귀 타입은 크기가 무한합니다 (Box를 사용하세요)'},
        \ {'pattern': 'insert some indirection.*`Box`',
        \  'translation': '간접 참조를 사용하세요 (예: `Box`)'},
        \
        \ {'pattern': 'type annotations needed for `\([^`]*\)`',
        \  'translation': '`%1`에 대한 타입 어노테이션이 필요합니다'},
        \ {'pattern': 'type annotations needed',
        \  'translation': '타입 어노테이션이 필요합니다'},
        \ {'pattern': 'consider giving this binding a type',
        \  'translation': '이 바인딩에 타입을 지정해 보세요'},
        \
        \ {'pattern': 'cannot infer type for type parameter `\([^`]*\)`',
        \  'translation': '타입 매개변수 `%1`의 타입을 추론할 수 없습니다'},
        \ {'pattern': 'cannot infer type',
        \  'translation': '타입을 추론할 수 없습니다'},
        \
        \ {'pattern': 'only traits defined in the current crate can be implemented for types defined outside',
        \  'translation': '현재 크레이트의 트레이트만 외부 타입에 구현할 수 있습니다 (고아 규칙)'},
        \
        \ {'pattern': 'method `\([^`]*\)` has an incompatible type for trait',
        \  'translation': '메서드 `%1`의 타입이 트레이트와 호환되지 않습니다'},
        \ {'pattern': 'not all trait items implemented, missing: `\([^`]*\)`',
        \  'translation': '트레이트 구현이 완전하지 않습니다. 누락: `%1`'},
        \ {'pattern': 'not all trait items implemented',
        \  'translation': '트레이트 구현이 완전하지 않습니다'},
        \
        \ {'pattern': 'cannot apply unary operator `!` to type `\([^`]*\)`',
        \  'translation': '타입 `%1`에 단항 연산자 `!`를 적용할 수 없습니다'},
        \ {'pattern': 'cannot apply unary operator `-` to type `\([^`]*\)`',
        \  'translation': '타입 `%1`에 단항 연산자 `-`를 적용할 수 없습니다'},
        \ {'pattern': 'binary operation `\([^`]*\)` cannot be applied to type `\([^`]*\)`',
        \  'translation': '이항 연산자 `%1`를 타입 `%2`에 적용할 수 없습니다'},
        \
        \ {'pattern': 'index out of bounds',
        \  'translation': '인덱스가 범위를 벗어났습니다'},
        \ {'pattern': 'attempt to compute .* which would overflow',
        \  'translation': '오버플로가 발생하는 연산입니다'},
        \ {'pattern': 'attempt to divide by zero',
        \  'translation': '0으로 나누기를 시도했습니다'},
        \
        \ {'pattern': 'the trait `\([^`]*\)` cannot be made into an object',
        \  'translation': '트레이트 `%1`를 객체로 만들 수 없습니다'},
        \ {'pattern': 'dyn Trait.*needs to be behind a pointer',
        \  'translation': '`dyn Trait`는 포인터 뒤에 있어야 합니다 (`&dyn` 또는 `Box<dyn>`)'},
        \ {'pattern': 'return type cannot have an unboxed trait object',
        \  'translation': '반환 타입에 박싱되지 않은 트레이트 객체를 사용할 수 없습니다'},
        \
        \ {'pattern': 'move occurs because `\([^`]*\)` has type `\([^`]*\)`, which does not implement the `Copy` trait',
        \  'translation': '`%1`의 타입 `%2`가 `Copy`를 구현하지 않아 이동이 발생합니다'},
        \ {'pattern': 'which does not implement the `Copy` trait',
        \  'translation': '`Copy` 트레이트를 구현하지 않습니다'},
        \
        \ {'pattern': 'method not found in `\([^`]*\)`',
        \  'translation': '`%1`에 메서드를 찾을 수 없습니다'},
        \
        \ {'pattern': 'cannot multiply `\([^`]*\)` by `\([^`]*\)`',
        \  'translation': '`%1`과 `%2`를 곱할 수 없습니다'},
        \ {'pattern': 'cannot add `\([^`]*\)` to `\([^`]*\)`',
        \  'translation': '`%2`에 `%1`을(를) 더할 수 없습니다'},
        \ {'pattern': 'cannot subtract `\([^`]*\)` from `\([^`]*\)`',
        \  'translation': '`%2`에서 `%1`을(를) 뺄 수 없습니다'},
        \ {'pattern': 'cannot divide `\([^`]*\)` by `\([^`]*\)`',
        \  'translation': '`%1`을(를) `%2`로 나눌 수 없습니다'},
        \
        \ {'pattern': 'temporary value dropped while borrowed',
        \  'translation': '빌린 임시 값이 소멸되었습니다'},
        \ {'pattern': 'creates a temporary value which is freed while still in use',
        \  'translation': '아직 사용 중인 임시 값이 해제됩니다'},
        \
        \ {'pattern': '`\([^`]*\)` is a raw pointer; try dereferencing it',
        \  'translation': '`%1`은(는) 원시 포인터입니다; 역참조해 보세요'},
        \ {'pattern': 'cast to unsized type',
        \  'translation': '크기를 알 수 없는 타입으로 캐스팅할 수 없습니다'},
        \
        \ {'pattern': '`#\[derive\]` can .* be used on structs, enums and unions',
        \  'translation': '`#[derive]`는 struct, enum, union에만 사용할 수 있습니다'},
        \ {'pattern': 'traits cannot be derived',
        \  'translation': '트레이트에는 derive를 적용할 수 없습니다'},
        \ ]

  let s:patterns_loaded = 1
  return s:patterns
endfunction

" ===========================================================================
" Warnings (74 entries)
" ===========================================================================
function! rustlings_ko#mappings#get_warnings() abort
  if s:warnings_loaded
    return s:warnings
  endif

  let s:warnings = [
        \ {'pattern': 'struct `\([^`]*\)` is never constructed',
        \  'translation': '구조체 `%1`는 한 번도 생성되지 않았습니다'},
        \ {'pattern': 'function `\([^`]*\)` is never used',
        \  'translation': '함수 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'associated function `\([^`]*\)` is never used',
        \  'translation': '연관 함수 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'method `\([^`]*\)` is never used',
        \  'translation': '메서드 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'field `\([^`]*\)` is never read',
        \  'translation': '필드 `%1`는 읽히지 않습니다'},
        \ {'pattern': 'constant `\([^`]*\)` is never used',
        \  'translation': '상수 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'enum `\([^`]*\)` is never used',
        \  'translation': '열거형 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'trait `\([^`]*\)` is never used',
        \  'translation': '트레이트 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'type alias `\([^`]*\)` is never used',
        \  'translation': '타입 별칭 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'variant `\([^`]*\)` is never constructed',
        \  'translation': '변형 `%1`는 한 번도 생성되지 않았습니다'},
        \ {'pattern': 'static `\([^`]*\)` is never used',
        \  'translation': '정적 변수 `%1`는 사용되지 않습니다'},
        \ {'pattern': 'unused variable: `\([^`]*\)`',
        \  'translation': '사용되지 않는 변수: `%1`'},
        \ {'pattern': 'unused import: `\([^`]*\)`',
        \  'translation': '사용되지 않는 가져오기: `%1`'},
        \ {'pattern': 'value assigned to `\([^`]*\)` is never read',
        \  'translation': '`%1`에 할당된 값이 읽히지 않습니다'},
        \ {'pattern': 'unused variable',
        \  'translation': '사용되지 않는 변수'},
        \ {'pattern': 'unused import',
        \  'translation': '사용되지 않는 가져오기'},
        \ {'pattern': 'unused mut',
        \  'translation': '불필요한 mut 지정자'},
        \ {'pattern': 'variable does not need to be mutable',
        \  'translation': '변수를 가변으로 지정할 필요가 없습니다'},
        \ {'pattern': 'dead_code',
        \  'translation': '사용되지 않는 코드'},
        \ {'pattern': 'unreachable_code',
        \  'translation': '도달할 수 없는 코드'},
        \ {'pattern': 'deprecated',
        \  'translation': '더 이상 사용되지 않습니다 (deprecated)'},
        \ {'pattern': 'value assigned .\+ is never read',
        \  'translation': '할당된 값이 읽히지 않습니다'},
        \ {'pattern': 'unused `#\[must_use\]`',
        \  'translation': '사용해야 하는 값이 사용되지 않았습니다 (#[must_use])'},
        \ {'pattern': 'irrefutable `if let` pattern',
        \  'translation': '반박 불가능한 `if let` 패턴입니다'},
        \ {'pattern': 'denote infinite loops with `loop',
        \  'translation': '무한 루프는 `loop`로 표현하세요'},
        \
        \ {'pattern': 'unused_assignments',
        \  'translation': '사용되지 않는 할당'},
        \ {'pattern': 'unused assignment',
        \  'translation': '사용되지 않는 할당'},
        \ {'pattern': 'path_statements',
        \  'translation': '효과 없는 경로 구문'},
        \ {'pattern': 'path statement with no effect',
        \  'translation': '효과 없는 경로 구문'},
        \ {'pattern': 'unnecessary parentheses',
        \  'translation': '불필요한 괄호'},
        \ {'pattern': 'unused_parens',
        \  'translation': '불필요한 괄호'},
        \ {'pattern': 'while_true',
        \  'translation': '`while true` 대신 `loop`를 사용하세요'},
        \ {'pattern': 'unconditional_recursion',
        \  'translation': '무조건적인 재귀 호출 (무한 재귀)'},
        \ {'pattern': 'unused_must_use',
        \  'translation': '사용해야 하는 값이 사용되지 않았습니다'},
        \ {'pattern': 'unreachable_patterns',
        \  'translation': '도달할 수 없는 패턴'},
        \ {'pattern': 'non_snake_case',
        \  'translation': '스네이크 케이스(snake_case)로 이름을 지어야 합니다'},
        \ {'pattern': 'non_camel_case_types',
        \  'translation': '카멜 케이스(CamelCase)로 이름을 지어야 합니다'},
        \ {'pattern': 'non_upper_case_globals',
        \  'translation': '대문자(UPPER_CASE)로 이름을 지어야 합니다'},
        \
        \ {'pattern': 'clippy::needless_return',
        \  'translation': '불필요한 `return`문입니다'},
        \ {'pattern': 'unneeded `return` statement',
        \  'translation': '불필요한 `return`문입니다'},
        \ {'pattern': 'clippy::redundant_clone',
        \  'translation': '불필요한 `clone()` 호출입니다'},
        \ {'pattern': 'clippy::needless_borrow',
        \  'translation': '불필요한 빌림(&)입니다'},
        \ {'pattern': 'clippy::manual_flatten',
        \  'translation': '`flatten()`을 사용하여 간소화할 수 있습니다'},
        \ {'pattern': 'clippy::collapsible_if',
        \  'translation': '중첩된 `if`를 하나로 합칠 수 있습니다'},
        \ {'pattern': 'clippy::needless_range_loop',
        \  'translation': '범위 루프 대신 이터레이터를 사용할 수 있습니다'},
        \ {'pattern': 'clippy::single_match',
        \  'translation': '단일 `match`는 `if let`으로 대체할 수 있습니다'},
        \ {'pattern': 'clippy::match_single_binding',
        \  'translation': '`match` 대신 `let`으로 바인딩할 수 있습니다'},
        \ {'pattern': 'clippy::len_zero',
        \  'translation': '`.len() == 0` 대신 `.is_empty()`를 사용하세요'},
        \ {'pattern': 'clippy::map_flatten',
        \  'translation': '`.map().flatten()` 대신 `.flat_map()`을 사용하세요'},
        \ {'pattern': 'clippy::iter_next_slice',
        \  'translation': '`.iter().next()` 대신 `.first()`를 사용하세요'},
        \ {'pattern': 'clippy::unwrap_used',
        \  'translation': '`unwrap()` 사용을 피하세요 (패닉 가능)'},
        \ {'pattern': 'clippy::expect_used',
        \  'translation': '`expect()` 사용을 피하세요 (패닉 가능)'},
        \ {'pattern': 'clippy::clone_on_copy',
        \  'translation': 'Copy 타입에 `clone()`은 불필요합니다'},
        \ {'pattern': 'clippy::derivable_impls',
        \  'translation': '`#[derive(Default)]`로 대체할 수 있습니다'},
        \ {'pattern': 'clippy::explicit_into_iter_loop',
        \  'translation': '`.into_iter()`를 명시적으로 호출할 필요 없습니다'},
        \ {'pattern': 'clippy::implicit_clone',
        \  'translation': '암묵적 클론 대신 `.clone()`을 명시적으로 호출하세요'},
        \ {'pattern': 'clippy::useless_vec',
        \  'translation': '`vec![]` 대신 슬라이스를 사용할 수 있습니다'},
        \ {'pattern': 'clippy::unnecessary_unwrap',
        \  'translation': '불필요한 `unwrap()` 호출입니다'},
        \ {'pattern': 'clippy::unused_self',
        \  'translation': '`self` 매개변수가 사용되지 않습니다'},
        \ {'pattern': 'clippy::wildcard_imports',
        \  'translation': '와일드카드(`*`) 가져오기를 피하세요'},
        \ {'pattern': 'clippy::unnecessary_cast',
        \  'translation': '불필요한 타입 캐스팅입니다'},
        \ {'pattern': 'clippy::redundant_field_names',
        \  'translation': '필드 이름이 변수 이름과 같으면 생략할 수 있습니다'},
        \ {'pattern': 'clippy::redundant_closure',
        \  'translation': '불필요한 클로저입니다 (함수를 직접 전달하세요)'},
        \ {'pattern': 'clippy::manual_map',
        \  'translation': '수동 `match` 대신 `.map()`을 사용하세요'},
        \ {'pattern': 'clippy::if_same_then_else',
        \  'translation': 'if/else 분기의 내용이 같습니다'},
        \ {'pattern': 'clippy::bool_comparison',
        \  'translation': '불필요한 bool 비교입니다'},
        \ {'pattern': 'clippy::string_lit_as_bytes',
        \  'translation': '`.as_bytes()` 대신 바이트 리터럴 `b"..."`를 사용하세요'},
        \ {'pattern': 'clippy::manual_strip',
        \  'translation': '`strip_prefix`/`strip_suffix`를 사용하세요'},
        \ {'pattern': 'clippy::match_ref_pats',
        \  'translation': 'match에서 참조 패턴 대신 역참조를 사용하세요'},
        \ {'pattern': 'clippy::ptr_arg',
        \  'translation': '`&Vec<T>` 대신 `&[T]`를, `&String` 대신 `&str`을 사용하세요'},
        \ {'pattern': 'clippy::large_enum_variant',
        \  'translation': '열거형 변형의 크기가 너무 큽니다 (Box를 사용하세요)'},
        \ {'pattern': 'clippy::type_complexity',
        \  'translation': '타입이 너무 복잡합니다 (타입 별칭을 사용하세요)'},
        \ {'pattern': 'clippy::too_many_arguments',
        \  'translation': '함수의 인수가 너무 많습니다'},
        \ {'pattern': 'clippy::missing_safety_doc',
        \  'translation': 'unsafe 함수에 안전성 설명이 없습니다'},
        \ ]

  let s:warnings_loaded = 1
  return s:warnings
endfunction

" ===========================================================================
" Hints (64 entries)
" ===========================================================================
function! rustlings_ko#mappings#get_hints() abort
  if s:hints_loaded
    return s:hints
  endif

  let s:hints = [
        \ {'pattern': 'consider borrowing here',
        \  'translation': '여기에서 빌림(&)을 사용해 보세요'},
        \ {'pattern': 'consider using a `let` binding',
        \  'translation': '`let` 바인딩을 사용해 보세요'},
        \ {'pattern': 'help: consider using',
        \  'translation': '도움말: 다음을 사용해 보세요'},
        \ {'pattern': 'did you mean `\([^`]*\)`?',
        \  'translation': '`%1`을(를) 의미하셨나요?'},
        \ {'pattern': 'help: use `mut`',
        \  'translation': '도움말: `mut`를 사용하세요'},
        \ {'pattern': 'consider adding a `;`',
        \  'translation': '`;`를 추가해 보세요'},
        \ {'pattern': 'perhaps a semicolon is missing',
        \  'translation': '세미콜론이 빠진 것 같습니다'},
        \ {'pattern': 'consider changing this to be mutable',
        \  'translation': '이것을 가변(mut)으로 변경해 보세요'},
        \ {'pattern': 'to force the closure to take ownership',
        \  'translation': '클로저가 소유권을 가지도록 하세요'},
        \ {'pattern': 'consider using `clone`',
        \  'translation': '`clone`을 사용해 보세요'},
        \ {'pattern': 'consider adding an explicit lifetime bound',
        \  'translation': '명시적 수명 바운드를 추가해 보세요'},
        \ {'pattern': 'consider restricting type parameter',
        \  'translation': '타입 매개변수에 제약을 추가해 보세요'},
        \ {'pattern': 'you can convert',
        \  'translation': '다음과 같이 변환할 수 있습니다'},
        \ {'pattern': 'try using a conversion method',
        \  'translation': '변환 메서드를 사용해 보세요'},
        \ {'pattern': 'if you meant to write a `str` literal',
        \  'translation': '`str` 리터럴을 작성하려면'},
        \
        \ {'pattern': 'consider adding `#\[derive(Debug)\]`',
        \  'translation': '`#[derive(Debug)]`를 추가해 보세요'},
        \ {'pattern': 'consider adding `#\[derive(Clone)\]`',
        \  'translation': '`#[derive(Clone)]`을 추가해 보세요'},
        \ {'pattern': 'consider adding `#\[derive(Copy)\]`',
        \  'translation': '`#[derive(Copy)]`를 추가해 보세요'},
        \ {'pattern': 'consider adding `#\[derive(PartialEq)\]`',
        \  'translation': '`#[derive(PartialEq)]`를 추가해 보세요'},
        \ {'pattern': 'consider adding `#\[derive(Default)\]`',
        \  'translation': '`#[derive(Default)]`를 추가해 보세요'},
        \ {'pattern': 'consider deriving `\([^`]*\)`',
        \  'translation': '`%1`을(를) derive해 보세요'},
        \
        \ {'pattern': 'consider adding a `where \([^`]*\)` bound',
        \  'translation': '`where %1` 바운드를 추가해 보세요'},
        \ {'pattern': 'consider adding a `use` for \(.\+\)',
        \  'translation': '%1에 대한 `use`를 추가해 보세요'},
        \ {'pattern': 'consider importing this',
        \  'translation': '이것을 import해 보세요'},
        \ {'pattern': 'consider importing one of these',
        \  'translation': '다음 중 하나를 import해 보세요'},
        \
        \ {'pattern': 'try wrapping the expression in `\([^`]*\)`',
        \  'translation': '표현식을 `%1`으로 감싸보세요'},
        \ {'pattern': 'expected due to this',
        \  'translation': '이것 때문에 해당 타입이 예상되었습니다'},
        \ {'pattern': 'arguments to this function are incorrect',
        \  'translation': '이 함수에 전달된 인수가 잘못되었습니다'},
        \ {'pattern': 'expected due to the type of this binding',
        \  'translation': '이 바인딩의 타입 때문에 해당 타입이 예상되었습니다'},
        \
        \ {'pattern': 'add `move` keyword before the closure',
        \  'translation': '클로저 앞에 `move` 키워드를 추가하세요'},
        \ {'pattern': 'consider using `impl Fn`',
        \  'translation': '`impl Fn`을 사용해 보세요'},
        \ {'pattern': 'consider adding return type',
        \  'translation': '반환 타입을 추가해 보세요'},
        \ {'pattern': 'consider giving this pattern a type',
        \  'translation': '이 패턴에 타입을 지정해 보세요'},
        \
        \ {'pattern': 'the return type of this call is `\([^`]*\)`',
        \  'translation': '이 호출의 반환 타입은 `%1`입니다'},
        \ {'pattern': 'this expression has type `\([^`]*\)`',
        \  'translation': '이 표현식의 타입은 `%1`입니다'},
        \ {'pattern': 'use `.as_ref()` to convert',
        \  'translation': '`.as_ref()`를 사용하여 변환하세요'},
        \ {'pattern': 'use `.as_mut()` to convert',
        \  'translation': '`.as_mut()`를 사용하여 변환하세요'},
        \ {'pattern': 'consider using `to_string()` method',
        \  'translation': '`to_string()` 메서드를 사용해 보세요'},
        \ {'pattern': 'consider using `&str` instead',
        \  'translation': '`&str`을 대신 사용해 보세요'},
        \ {'pattern': 'consider using `String` instead',
        \  'translation': '`String`을 대신 사용해 보세요'},
        \
        \ {'pattern': 'help: remove this',
        \  'translation': '도움말: 이것을 제거하세요'},
        \ {'pattern': 'help: add this',
        \  'translation': '도움말: 이것을 추가하세요'},
        \ {'pattern': 'help: change this to',
        \  'translation': '도움말: 이것을 변경하세요'},
        \ {'pattern': 'help: if this is intentional, prefix it with an underscore',
        \  'translation': '도움말: 의도적이라면 이름 앞에 `_`를 붙이세요'},
        \ {'pattern': 'prefix .* with an underscore',
        \  'translation': '이름 앞에 `_`를 붙이세요'},
        \
        \ {'pattern': 'consider boxing the return type',
        \  'translation': '반환 타입을 `Box`로 감싸보세요'},
        \ {'pattern': 'consider changing this to `&\([^`]*\)`',
        \  'translation': '`&%1`로 변경해 보세요'},
        \ {'pattern': 'consider adding `move` keyword',
        \  'translation': '`move` 키워드를 추가해 보세요'},
        \ {'pattern': 'consider using `\([^`]*\)` instead',
        \  'translation': '`%1`을(를) 대신 사용해 보세요'},
        \
        \ {'pattern': 'one type is more general than the other',
        \  'translation': '하나의 타입이 다른 타입보다 더 일반적입니다'},
        \ {'pattern': 'lifetime mismatch',
        \  'translation': '수명이 일치하지 않습니다'},
        \ {'pattern': 'first, the lifetime cannot outlive',
        \  'translation': '우선, 수명이 다른 것보다 오래 살 수 없습니다'},
        \ {'pattern': 'but, the lifetime must be valid for',
        \  'translation': '하지만, 수명이 유효해야 합니다'},
        \
        \ {'pattern': 'help: store this in the heap by calling `Box::new`',
        \  'translation': '도움말: `Box::new`로 힙에 저장하세요'},
        \ {'pattern': 'help: consider adding a `\([^`]*\)` impl for',
        \  'translation': '도움말: `%1` 구현을 추가해 보세요'},
        \ {'pattern': 'help: consider annotating .* with `#\[derive(\([^)]*\))\]`',
        \  'translation': '도움말: `#[derive(%1)]`를 추가해 보세요'},
        \
        \ {'pattern': 'required by a bound introduced by this call',
        \  'translation': '이 호출에 의해 도입된 바운드에 의해 필요합니다'},
        \ {'pattern': 'required by this bound in `\([^`]*\)`',
        \  'translation': '`%1`의 이 바운드에 의해 필요합니다'},
        \ {'pattern': 'required for `\([^`]*\)` to implement `\([^`]*\)`',
        \  'translation': '`%1`이(가) `%2`를 구현하기 위해 필요합니다'},
        \
        \ {'pattern': 'help: use `dyn`',
        \  'translation': '도움말: `dyn` 키워드를 사용하세요'},
        \ {'pattern': 'note: `\([^`]*\)` is defined in an external crate',
        \  'translation': '참고: `%1`은(는) 외부 크레이트에 정의되어 있습니다'},
        \ {'pattern': 'note: for more information, visit',
        \  'translation': '참고: 자세한 정보는 다음 링크를 방문하세요'},
        \ {'pattern': 'help: consider using `\([^`]*\)` here',
        \  'translation': '도움말: 여기에서 `%1`을(를) 사용해 보세요'},
        \ {'pattern': 'use `&raw const` instead to create a raw pointer',
        \  'translation': '원시 포인터를 만들려면 `&raw const`를 사용하세요'},
        \ ]

  let s:hints_loaded = 1
  return s:hints
endfunction

let &cpo = s:save_cpo
unlet s:save_cpo
